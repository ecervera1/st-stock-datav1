# -*- coding: utf-8 -*-
"""Portfolio Optimization 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tnBY-qKfIquFrFpNY3edffUszuY26pXq
"""

# Description: This program attempts to optimize a UD SMIF Portfolio using efficient frontier and python

pip install pandas_datareader

pip install PyPortfolioOpt

# Import the python libraries
from pandas_datareader import data as web
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

# Stock tickeers in portfolio Edit this box for different assets in portfolio
assets= ['MA','SPG','BAC','JPM','BLK','SOFI','COIN']

#Assing weights to the stock. Edit this bos for different weights
weights = np.array([0.24,0.30,0.10,0.04,0.25,0.02,0.05])

#Get stock starting date
stockstartdate='2013-01-01'

#Stock ending date
today= datetime.today().strftime('%Y-%m-%d')
today

# Create a dataframe to store the adjusted close price of stocks
df = pd.DataFrame()

# Store adjusted closed price of stock into df
for stock in assets:
    df[stock] = web.DataReader(stock, data_source='yahoo', start = stockstartdate, end=today)['Adj Close']

#Show the df
df

#Visually show the stock / portfolio
title = 'Portfolio Adj. Close Price History'

#Get stocks
my_stocks = df

#Create and plot the graph
for c in my_stocks.columns.values:
    plt.plot(my_stocks[c], label=c)

plt.title(title)
plt.xlabel('Date', fontsize=18)
plt.legend(my_stocks.columns.values, loc='upper left')
plt.show

# Show daily simple return
returns = df.pct_change()
returns

#Number of days in a year
day_of_year = datetime.now().timetuple().tm_yday
day_of_year

# Annualized Covariance matrix
cov_matrix_annual= returns.cov() * day_of_year
cov_matrix_annual

# Portfolio Variance

portfolio_variance = np.dot(weights.T, np.dot(cov_matrix_annual,weights))
portfolio_variance

#Portfolio STD/ Volatility
portfolio_volatility = np.sqrt(portfolio_variance)
portfolio_volatility

#Annual Portfolio Return
portfolio_return=(np.sum(returns.mean()*weights)*day_of_year)
portfolio_return

#Show expected annual return, Volatility, and Variance
percent_return= str(round(portfolio_return,2)*100)+'%'
percent_volatility=str(round(portfolio_volatility,2)*100)+'%'
percent_variance= str(round(portfolio_variance,2)*100)+'%'
print('Expected Annual Return:' + percent_return)
print('Annual Volatility:' + percent_volatility)
print('Annual Variance:' + percent_variance)

#Open packages to optimize portfolio
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models
from pypfopt import expected_returns

#Portfolio Optimization
#Calculate the expected returns and the annualised sample covariance of asset returns
mu = expected_returns.mean_historical_return(df)
S = risk_models.sample_cov(df)

#Optimize for Max Sharpe Ratio
ef = EfficientFrontier(mu, S)
weights = ef.max_sharpe()
cleaned_weights = ef.clean_weights()
print(cleaned_weights)
ef.portfolio_performance(verbose = True)

# Discrete allocation of each share per stock
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices
latest_prices = get_latest_prices(df)
wegihts = cleaned_weights
da = DiscreteAllocation(weights, latest_prices, total_portfolio_value = 14276)

allocation , leftover = da.lp_portfolio()
print('Discrete allocation:', allocation)
print('Funds Remaining; ${:.2f}'.format(leftover))

